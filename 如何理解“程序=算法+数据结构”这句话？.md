# 如何理解“程序=算法+数据结构”这句话？

[toc]

## 0 引言

>  程序 = 算法 + 数据结构

这句简洁有力的格言，由瑞士计算机科学家**尼克劳斯·沃斯（Niklaus Wirth）**在其1976年出版的经典著作《算法 + 数据结构 = 程序》中提出。它深刻地揭示了构建有效程序的核心要素及其相互关系。尽管软件工程历经数十年发展，涌现出面向对象、函数式等众多范式和复杂框架，但这句箴言依然闪烁着智慧的光芒，是理解程序本质、设计高质量软件的基础性原则。

## 1 什么是算法与数据结构

- **算法：** 算法是解决特定问题或执行特定计算任务的一系列清晰、有限、可执行的步骤或指令序列。它定义了“如何做”的问题。
  - **常见例子：** 排序（快速排序、归并排序、冒泡排序）、搜索（二分查找、广度优先搜索、深度优先搜索）、图算法（Dijkstra最短路径）、动态规划、递归等
- **数据结构：** 数据结构是计算机中存储、组织和管理数据的一种特定方式。它定义了数据元素之间的逻辑关系以及在这些数据上执行的操作。它关注的是“数据如何组织”的问题。
  - **常见例子：**数组、链表（单链表、双链表）、栈、队列、树（二叉树、二叉搜索树、堆、AVL树、B树）、图（邻接矩阵、邻接表）、哈希表、集合、字典/映射。

选择合适的算法和数据结构能极大影响程序的效率和简洁性。

算法的操作对象是数据结构中的数据。算法的设计、效率和实现方式很大程度上取决于它所操作的数据结构。例如，在链表上实现高效随机访问很困难，但在数组上则很容易。

数据结构的设计是为了高效地支持特定算法的操作。例如，栈是为了高效支持后进先出（LIFO）操作，队列是为了先进先出（FIFO），哈希表是为了极快的查找和插入。

针对同一个问题，选择不同的数据结构和算法组合，会产生截然不同的程序效率和资源消耗。

## 2 什么是程序

理解了算法和数据结构是什么，我们就能更清晰地定义程序：**程序是算法和数据结构在特定编程语言中的具体实现**。它是一系列指令的集合，这些指令精确地描述了如何操作（**算法**）特定组织的数据（**数据结构**），以解决某个问题或完成特定任务。

### 2.1 实际系统中的选择与应用

> 程序 = 算法 + 数据结构

这并非抽象理论，它直接体现在我们构建的每一个软件系统中，以下是一些经典例子。

#### 场景1：数据库索引

*当你使用 `SELECT * FROM users WHERE id = 123456;` 在包含数十亿条记录的表中，如何极快地定位到特定记录？*

在MySQL中，其索引的标准实现方式是使用**B+树**。**B+树**是一种多路平衡搜索树。其结构特点（扁平化、多子节点、叶子节点链表串联）**专门为磁盘I/O优化**。它最小化了查找记录时需要访问的磁盘块次数。而平衡树的操作算法确保了即使在频繁插入/删除后，树的高度（即查找路径长度）始终保持在对数级别 ($O(log n)$)，保证了操作的高效性。没有高效的**B+树**结构和对应的平衡算法，数据库处理大数据量时的查询速度将急剧下降。选择**B+树**而非其他树（如普通二叉搜索树）就是因为它更好地匹配了磁盘存储特性和范围查询需求（通过叶子节点链表）。

#### 场景2：操作系统任务调度

*在拥有成百上千个进程/线程的现代操作系统中，如何决定下一个该由哪个任务运行，既要保证响应性（交互式任务），又要保证吞吐量（计算密集型任务），还要防止饥饿？*

在Linux CFS中使用了**红黑树**来解决这样的问题。**红黑树**用于组织所有可运行的进程。并基于优先级、时间片轮转、虚拟运行时间进行进程调度。进程按照其计算出的`vruntime`（虚拟运行时间）作为键值存储在**红黑树**中。当进程变为可运行或阻塞时，高效（$O(log n)$）地将其插入或从**红黑树**中删除。调度器总是选择`vruntime`最小的进程（即**红黑树**最左侧节点），这保证了最“欠”CPU时间的进程优先运行，实现近似完美的公平调度（$O(1)$选择复杂度）。**红黑树**优秀的$O(log n)$插入/删除性能和$O(1)$获取最小值性能，完美支撑了CFS调度算法的公平性和高效性要求。而其他数据结构（如简单链表）很难实现这种高效的公平调度。

#### 场景3：网络路由

*路由器如何在海量的网络拓扑信息中，为数据包找到一条到达目标地址的最佳（最快、最不拥塞）路径？*

**图**的组织结构使得路由器能理解网络连接关系，路由器作为顶点（`Vertex`），网络连接作为边（`Edge`），链路状态（带宽、延迟、开销）作为边的权重（`Weight`）。而高效的最短路径算法（如Dijkstra算法用于OSPF链路状态路由，Bellman-Ford算法用于RIP距离矢量路由）则能在网络变化时快速重新计算最优路径，确保数据包高效、可靠地传输。算法的效率（如Dijkstra的$O(V^2)$或$O(E + V log V)$）直接决定了路由器收敛速度和网络稳定性。由此计算从一个源点到所有其他点的最短（最小代价）路径。它们高效地遍历图结构，利用权重信息做出路径选择。

### 2.2 深刻理解“程序 = 算法 + 数据结构”

以上例子清晰地展示了：一个功能正确、性能高效的程序，必然针对特定问题，精心挑选或设计了最匹配的**数据结构**来组织数据，并实现了高效操作该数据结构的**算法**。二者缺一不可，相互成就。 它揭示了程序运行的底层核心逻辑——对数据的操作（**算法**）和数据的表示（**数据结构**）。无论程序多么庞大或使用了何种高级框架，最终的执行都落实到这些基本操作上。我们在设计时必须同时思考：“我的核心数据是什么？如何组织它？我需要对它做什么操作？哪种算法做这个操作最高效？” 这是性能优化和架构设计的起点。 程序的效率（速度、内存消耗）首要决定因素就是所选算法和数据结构及其契合度。数据库慢？可能是索引（**数据结构**）没建好或查询（**算法**）没优化。调度器卡顿？可能是任务队列（**数据结构**）选择不当或调度策略（**算法**）低效。现代软件工程（OOP、设计模式、分布式系统）构建在更高级的抽象之上，但这些抽象内部和之间的数据流动与处理，最终都依赖于底层高效的**算法**与**数据结构**组合。它们是构建高楼大厦的砖瓦。

## 3 公式的应用和启示

### 3.1 在日常编码与软件工程中的应用

面对新问题时，开发者本能地会思考：“处理什么数据？如何组织这些数据？需要哪些操作？哪种算法最有效？” 公式能够引导开发者从**算法**和**数据结构**两个维度切入设计。

程序性能瓶颈往往源于不合适的算法或数据结构。优化通常意味着：寻找更优算法（如将$O(n^2)$排序换成$O(n log n)$）、更换更匹配操作需求的数据结构（如将列表查找换成哈希表）、调整现有数据结构以更好地配合算法（如树结构的平衡）。

选择业界公认、适合场景的标准算法和数据结构（如使用 `HashMap` 而非自己模拟），能显著提高代码的清晰度和可理解性，降低维护成本。优秀的库（如 Java Collections Framework、C++ STL、Python collections）的核心价值在于提供了经过千锤百炼、高效实现的**数据结构**及其配套的操作**算法**（迭代器、排序、查找等方法）。

另外算法与数据结构也是评估程序员基本功和问题解决能力的最主要领域，因为它们直接反映了对程序本质的理解和编码能力。

### 3.2 日常生活中的拓展与启示

透过问题看本质，其实日常生活也可以总结概括为

> 程序 = 算法 + 数据结构

我们完成日常任务的步骤、流程、策略就是**算法**，例如：高效工作法、烹饪食谱、旅行规划路线、解决问题的思考框架。而对时间、物品、信息的管理方式则是**数据结构**，例如：时间管理工具（日历/待办列表）、家居物品收纳、知识管理（笔记分类/标签）等等。

要高效、有条理地“运行”好生活这个“程序”，既要优化做事的流程和方法，也要精心组织和管理资源。杂乱无章的环境会拖累任何好方法；而笨拙的方法也无法充分利用良好组织带来的便利。

这也给我们一个启示，事实上我们透过问题看本质就是训练我们抽象和分解复杂事物的能力。将任何系统或过程看作“数据”和“对数据的操作”，是一种强大的思维模式。它展示了复杂系统由更简单、相互依赖的组件组合而成。理解整体需要理解部分及其交互。

生活中也充满选择。公式提醒我们，面对问题，解决方案的有效性高度依赖于我们选择的“方法”和“组织形式”。没有放之四海而皆准的最优解，只有**适合特定情境**的最优组合，就是要具体问题具体分析。

## 4 总结

> 程序 = 算法 + 数据结构

这绝非一句过时的口号，而是计算机科学中揭示程序本质的永恒真理。它精辟地指出，构建有效程序的核心在于精心设计操作数据的步骤（**算法**）和高效组织数据本身的方式（**数据结构**），二者密不可分，共同决定了程序的正确性、效率和可维护性。

深刻理解并熟练应用这一公式，是程序员核心能力的体现。它指导我们进行合理的设计决策、精准的性能优化，并编写出清晰、健壮的代码。即使在软件工程高度发展的今天，面对复杂的系统和框架，其底层运作机制依然回归到这个基础等式。

更重要的是，这一公式所蕴含的抽象思维、组合思维以及强调选择的智慧，超越了编程领域。它是一种强大的方法论，能帮助我们更清晰、更高效地分析和解决生活与工作中的各种复杂问题。掌握这种思维，不仅是成为优秀程序员的基石，更是提升个人解决问题能力的有效途径。